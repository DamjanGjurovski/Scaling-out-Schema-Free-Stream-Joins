Scaling Out Schema-free Stream Joins
======

---

Introduction
------

---

In this work, we consider computing natural joins over massive streams of JSON documents that do not adhere to a specific schema. 
We first propose an efficient and scalable partitioning algorithm that uses the main principles of association analysis to identify patterns of co-occurrence
of the attribute-value pairs within the documents. Data is then accordingly forwarded to compute nodes and locally joined using a novel FP-tree--based join algorithm. 
By compactly storing the documents and efficiently traversing the FP-tree structure, the proposed join algorithm can operate on large input sizes and provide results in real-time. 
We discuss data-dependent scalability limitations that are inherent to natural joins over schema-free data and show how to practically circumvent them by artificially expanding the 
space of possible attribute-value pairs. The proposed algorithms are realized in the Apache Storm stream processing framework. Through extensive experiments with real-world as well as 
synthetic data, we evaluate the proposed algorithms and show that they outperform competing approaches.

Dataset
------

---
As a dataset, we use NoBench [1]. In this repository, there is a sample of 10,000,000 JSON objects (which we treat as documents) generated with the NoBench generator that can be used for testing the streaming application. 
The documents are located in the folder `data/`. 
There are 100 documents where every document contains 100,000 JSON objects. 

Running the application
------

---

The main class consisting of the settings for running the proposed Apache Storm topology is called *AssociationGroupsTopology.java*. 

For every component (spout or bolt), the number of instances can be varied by modifying the respective variable in the *AssociationGroupsTopology* class. The required number of partitions
can be specified through the variable `k`. The number of partitions is directly connected to the number of *FPTreeJoinerBolt* instances, so always the number of partitions `k` needs to be equal
to the number of joiner instances defined by the variable `numberOfInstancesForFpTreeJoinerBolt`.

The window size, representing the number of documents that will be used for partitioning, can be varied by modifying the `windowSize` variable. 
The currently specified size of the window is 430,000 documents, which corresponds to a 3-minute window. For a 6 and 9 minute window, this number needs to be multiplied by 2 and 3 respectively. 

The path to the input folder consisting of JSON documents generated by NoBench can be specified through the `pathToStoringFolder` variable. If there is a need for using different documents, the *NoBenchSpout*
responsible for parsing the documents should be modified. 

If there is a need for expanding attributes, the `performJoinOfKVPairs` variable should be set to true. The expansion of attributes is required when there is an attribute whose number of unique values
is smaller than the required number of partitions. 

To store the computed join results in CSV files first the path to output folder needs to be set in the *JoinResultsCsvOutput* class by modifying the `pathToFolder` variable. Secondly, the required lines 
that perform the creation of the files need to be uncommented in the *FPTreeJoinerBolt* class.

#### Local mode 

Using the command: `mvn compile exec:java -Dstorm.topology=ssfsj.AssociationGroupsTopology`

### Cluster
The needed JAR can be created using the command: `mvn assembly:assembly`. Once the JAR is transfered to the cluster, 

the command `path-to-storm/storm jar ScalingOutSchemaFreeStreamJoins-1.0-SNAPSHOT-jar-with-dependencies.jar ssfsj.AssociationGroupsTopology association-groups-topology`,

can be used for starting the application on the Storm cluster. 

References
------

---
[1] - C. Chasseur, Y. Li, and J. M. Patel, “Enabling JSON document stores in relational systems,” WebDB 2013, pp. 1–6, 2013.